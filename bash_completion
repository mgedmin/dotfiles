#
# 'inst' is an alias to sudo apt-get install
#
_apt_packages()
{
    local cur prev
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    if [ $prev = -t ]; then
        COMPREPLY=( $( apt-cache policy | grep "release.o=Debian,a=$cur" | \
                       sed -e "s/.*a=\(\w*\).*/\1/" | uniq ) )
        return 0
    fi
    COMPREPLY=( $( apt-cache pkgnames $cur 2> /dev/null ) )
    return 0
}
complete -F _apt_packages inst apt-changelog dpkg-changelog

#
# mtr is a better traceroute
# multiping.py is a better ping
#
complete -F _known_hosts mtr multiping.py

#
# 'scp': default scp completion expands 'host:pat' -> 'host:host\:path/'
#
_scp()
{
        local cur userhost path

        COMPREPLY=()
        cur=${COMP_WORDS[COMP_CWORD]}

        _expand || return 0

        if [[ "$cur" == *:* ]]; then
                # remove backslash escape from :
                cur=${cur/\\:/:}
                userhost=${cur%%?(\\):*}
                path=${cur#*:}
                if [ -z "$path" ]; then
                        # default to home dir of specified user on remote host
                        path=$( ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null)
                fi
                COMPREPLY=( $( compgen \
                               -W "`echo $( ssh -o 'Batchmode yes' $userhost \
                                            compgen -f -- $path 2>/dev/null)`"))
                return 0
        fi

        [[ "$cur" == */* ]] || _known_hosts -c -a
        _filedir

        return 0
}
complete $filenames -F _scp $nospace scp

#
# eazysvn is https://github.com/mgedmin/eazysvn
#
_eazysvn()
{
    local cur
    cur=${COMP_WORDS[COMP_CWORD]}
    prev=${COMP_WORDS[COMP_CWORD-1]}
    case $prev in
      switch|rmbranch|mvbranch|branchurl|branchdiff|branchpoint)
        COMPREPLY=( $( compgen -W "`ezswitch -l 2> /dev/null`" $cur ) )
        return 0
        ;;
    esac
    COMPREPLY=( $( compgen -W "branchdiff branchpoint branchurl help merge mvbranch revert rmbranch selftest switch tag" $cur ) )
    return 0
}
complete -F _eazysvn eazysvn

# ezswitch/ezbranch are from eazysvn (https://github.com/mgedmin/eazysvn)
_ezswitch()
{
    local cur
    cur=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=( $( compgen -W "`ezswitch -l 2> /dev/null`" $cur ) )
    return 0
}
complete -F _ezswitch ezswitch ezbranch

#
# Fabric completion
# based on https://github.com/marcelor/fabric-bash-autocompletion/blob/master/fab
# 
_fab()
{
    local cur
    fab=${COMP_WORDS[0]}
    cur=${COMP_WORDS[COMP_CWORD]}
    local tasks=$("$fab" -l 2>/dev/null | sed -ne '/^Available commands/,$p' | grep "^    " | awk '{print $1;}')
    COMPREPLY=( $( compgen -W "${tasks}" $cur ) )
    return 0
}
# pov-fab is an alias for fab -f ~/src/pov-admin/fabfile.py
complete -F _fab fab bin/fab pov-fab

#
# Bugfix for Mutt completion
# https://bugs.launchpad.net/ubuntu/+source/bash-completion/+bug/1008380
# this fixes mutt -f +x<tab>, but breaks mutt -f =x<tab>, which works with the
# stock completion
#
##if [ -f /usr/share/bash-completion/completions/mutt ]; then
##    . /usr/share/bash-completion/completions/mutt
##fi
##_muttfiledir()
##{
##    local cur=$1 folder muttrc spoolfile muttcmd=${words[0]}
##
##    muttrc=$(_muttrc)
##    if [[ $cur == [=+]* ]]; then
##        folder="$( $muttcmd -F "$muttrc" -Q folder 2>/dev/null | sed -e 's|^folder=\"\(.*\)\"$|\1|' )"
##        : folder:=~/Mail
##
##        # Match any file in $folder beginning with $cur
##        # (minus the leading '=' sign).
##        compopt -o filenames
##        COMPREPLY=( $( compgen -f -- "$folder/${cur:1}" ) )
##        COMPREPLY=( ${COMPREPLY[@]/#$folder\//${cur:0:1}} )
##        return 0
##    elif [[ $cur == !* ]]; then
##        spoolfile="$( $muttcmd -F "$muttrc" -Q spoolfile 2>/dev/null | \
##            sed -e 's|^spoolfile=\"\(.*\)\"$|\1|' )"
##        [[ ! -z $spoolfile ]] && eval cur="${cur/^!/$spoolfile}"
##    fi
##    _filedir
##
##    return 0
##}

#
# Source ~/.bash_completion.d/*.bash
#
if [[ -d ~/.bash_completion.d/ ]]; then
    for i in ~/.bash_completion.d/*.bash; do
        [[ -f $i ]] && . "$i"
    done
fi
